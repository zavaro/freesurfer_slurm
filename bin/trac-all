#! /bin/tcsh -f

#
# trac-all
#
# For when you need to look beneath the surface
#
# Original Author: Anastasia Yendiki
# CVS Revision Info:
#    $Author: zkaufman $
#    $Date: 2016/12/20 17:04:05 $
#    $Revision: 1.60.2.1 $
#
# Copyright Â© 2011 The General Hospital Corporation (Boston, MA) "MGH"
#
# Terms and conditions for use, reproduction, distribution and contribution
# are found in the 'FreeSurfer Software License Agreement' contained
# in the file 'LICENSE' found in the FreeSurfer distribution, and here:
#
# https://surfer.nmr.mgh.harvard.edu/fswiki/FreeSurferSoftwareLicense
#
# Reporting: freesurfer@nmr.mgh.harvard.edu
#
#

umask 002

set VERSION = '$Id: trac-all,v 1.60.2.1 2016/12/20 17:04:05 zkaufman Exp $'
set ProgName = `basename $0`
set inputargs = ($argv)

if ($?PBS_JOBID && `domainname` == nmr.mgh.harvard.edu) then
  echo "WARN: The intended usage of $ProgName is not to submit it as a job."
  echo "WARN: It is to be run directly on the command line."
  echo "WARN: If run on the cluster, $ProgName will submit the jobs for you."
  echo "WARN: Each subject listed in your dmrirc will be submitted as a job."
  echo "WARN: If run on a single node, it will run everything serially."
endif

set onpbs = 0
set hname = `hostname -s`
if ($hname == tensor || $hname == launchpad) then
  set onpbs = 1
endif

setenv FSLOUTPUTTYPE NIFTI_GZ
setenv LANG en_US.UTF-8

#------------ Set default options -----------------------------------------#

set PrintHelp = 0	# Print help and exit
set DoVersionsOnly = 0	# Print versions and exit

set debug = 0		# Generate more output
set umaskid = ()	# Unix file permission mask
set groupid = ()	# Unix user group ID
set allowcore = 0	# Unlimit core dump size

set DoTime = 0		# Time main commands
set fs_time = ()

set submitfile = ()	# Name of file for writing jobs to be run in parallel

set logfile = ()	# Name of log file
set cmdfile = ()	# Name of command file
set AppendLog = 1	# Append to log file if it exists

set DoIsRunning = 1     # Create a lock file while processing continues

set RunIt = 1		# If 0, do everything but run commands (for debugging)

set DoCleanCSDF = 0	# If 1, ignore FREESURFER_HOME of previous processing

set dopreproc = 0	# Perform select processing steps
set dobedpost = 0
set dopaths = 0
set dostats = 0

set docorr = 0
set doqa = 0
set dointra = 0
set dointer = 0
set domasks = 0
set dotensor = 0
set dopriors = 0

set rcfile = ()		# Run command file

#------------ Parse input arguments and configuration file ----------------#

if ($#argv == 0) goto usage_exit;

set n = `echo $argv | egrep -e -help | wc -l`
if ($n != 0) then
  set PrintHelp = 1
  goto usage_exit;
endif

set n = `echo $argv | egrep -e -version | wc -l`
if ($n != 0) then
  echo $VERSION
  exit 0
endif

# Set defaults
set dtroot = ()
set subjlist = ()
set runlist = ()
set dcmroot = ()
set dcmlist = ()
set bveclist = ()
set bvecfile = ()
set bvallist = ()
set bvalfile = ()
set nb0 = ()
set dob0 = 0
set b0mlist = ()
set b0plist = ()
set echospacing = ()
set doeddy = 1
set dorotbvecs = 1
set thrbet = 0.3
set doregflt = 0
set doregbbr = 1
set doregmni = 1
set doregcvs = 0
set mnitemp = $FSLDIR/data/standard/MNI152_T1_1mm_brain.nii.gz
set cvstempdir = $FREESURFER_HOME/subjects
set cvstemp = cvs_avg35
set usemaskanat = 1
set baselist = ()
set pathlist = ( lh.cst_AS rh.cst_AS \
                 lh.ilf_AS rh.ilf_AS \
                 lh.unc_AS rh.unc_AS \
                 fmajor_PP fminor_PP \
                 lh.atr_PP rh.atr_PP \
                 lh.ccg_PP rh.ccg_PP \
                 lh.cab_PP rh.cab_PP \
                 lh.slfp_PP rh.slfp_PP \
                 lh.slft_PP rh.slft_PP )
set ncpts = (6 6 5 5 5 5 7 5 5 5 5 5 4 4 5 5 5 5)
set trainfile = $FREESURFER_HOME/trctrain/trainlist.txt
set trainsubjlist = ()
set ntrainlist = ()
set avgname = ()
set reinit = 0
set usetrunc = 1
set do1out = 0
set doxyzprior = 0
set dosegprior = 1
set dotangprior = 0
set dopathsubdirs = 0
set nstick = 2
set fmin = 0.05
set nburnin = 200
set nsample = ()		# Default is set below
set nupdate = 0
set nkeep = 5
set doinitprop = 1
set overwrite = 1
set trcdir = $FREESURFER_HOME/bin

source $FREESURFER_HOME/sources.csh

goto parse_args;
parse_args_return:

# Source run command file
if ($#rcfile) source $rcfile

# Set default number of samples for cross-sectional or longitudinal case
if ($#nsample == 0) then
  if ($#baselist == 0) then
    set nsample = 7500
  else
    set nsample = 12000
  endif
endif

goto check_params;
check_params_return:

echo "INFO: SUBJECTS_DIR is $SUBJECTS_DIR"
echo "INFO: Diffusion root is $dtroot"

pushd $FREESURFER_HOME > /dev/null
set freesurfer_home_true = `pwd`;
popd > /dev/null
echo "Actual FREESURFER_HOME $freesurfer_home_true"

if ($onpbs) then
  set pbslogdir = /tmp/trac-all.$$
  mkdir -p $pbslogdir
  if (! $#submitfile) set submitfile = $pbslogdir/submit.txt
endif

if ($#submitfile) then
  rm -f $submitfile

  set presubmitfile = `echo $submitfile | awk -v FS=\. \
    '{s=""; for (i=1;i<NF;i++) s=s$i"."; print s"pre."$NF}'`
  rm -f $presubmitfile

  set postsubmitfile = `echo $submitfile | awk -v FS=\. \
    '{s=""; for (i=1;i<NF;i++) s=s$i"."; print s"post."$NF}'`
  rm -f $postsubmitfile
endif

if ($#logfile) then
  if (-e $logfile && ! $AppendLog) mv -f $logfile $logfile.old
endif

if ($#cmdfile) then
  rm -f $cmdfile
endif

set cmdopts = ()
if ($DoTime) set cmdopts = ($cmdopts -time)
if (! $DoIsRunning) set cmdopts = ($cmdopts -no-isrunning)
if (! $RunIt) set cmdopts = ($cmdopts -dontrun)
if ($debug) set cmdopts = ($cmdopts -debug)
if ($#umaskid) set cmdopts = ($cmdopts -umask $umaskid)
if ($#groupid) set cmdopts = ($cmdopts -grp $groupid)
if ($allowcore) set cmdopts = ($cmdopts -allowcoredump)

#------------ Loop over subjects ------------------------------------------#
set subjdirs = ()
set basedirs = ()

if ($#baselist == 0) then	#--->>> A single time point for each subject
  foreach isubj ($runlist)
    set subj = $subjlist[$isubj]

    if ($do1out) then
      set dtdir = $subj
      set dtroot = `dirname $dtdir`
      set subj = `basename $dtdir`

      if (-e $trainfile) then
        set trainsubjlist = `cat $trainfile | sed -n "$isubj p"`
        shift trainsubjlist
      endif
    else
      set dtdir = $dtroot/$subj

      if (-e $trainfile) then
        set trainsubjlist = `cat $trainfile`
      endif
    endif

    set subjdirs = ($subjdirs $dtdir)

    if ($dostats) continue

    # Check freesurfer directory
    if (($dointra || $dointer || $domasks) && ! $do1out) then
      set fsdir = $SUBJECTS_DIR/$subj

      if (! -e $fsdir) then
        echo "ERROR: cannot find $fsdir"
        exit 1
      endif

      if (! -r $fsdir) then
        echo "ERROR: $fsdir exists but is unreadable"
        exit 1
      endif
    endif

    mkdir -p $dtdir/scripts

    # Check diffusion directory
    if (! -w $dtdir) then
      echo "ERROR: cannot write in $dtdir"
      exit 1
    endif

    #---------- Check build stamp -------------------------------------------#
    # This allows the user to require that the build stamp be
    # consistent from one trac-all/recon-all invocation to the next.
    # Good for frozen versions.

    if ($?REQUIRE_FS_MATCH == 0) setenv REQUIRE_FS_MATCH 0

    set bstampfile0 = $FREESURFER_HOME/build-stamp.txt
    set bstampfile  = $dtdir/scripts/build-stamp.txt

    if (-e $bstampfile0) then
      if (! -e $bstampfile) cp $bstampfile0 $bstampfile

      set bstamp0 = `cat $bstampfile0`
      set bstamp  = `cat $bstampfile`

      if ("$bstamp0" != "$bstamp") then
        if ($REQUIRE_FS_MATCH) then
          echo "ERROR: FreeSurfer build stamps do not match"
          echo "Subject Stamp: $bstamp"
          echo "Current Stamp: $bstamp0"
          exit 1;
        else
          echo "INFO: FreeSurfer build stamps do not match"
          echo "Subject Stamp: $bstamp"
          echo "Current Stamp: $bstamp0"
        endif
      endif
    endif

    #---------- Create log and command files --------------------------------#

    if ($DoVersionsOnly) then
      if (-e /dev/stdout) then
        set LF = /dev/stdout
      else
        set LF = /dev/null
      endif
    else
      if ($#logfile) then
        if (`basename $logfile` == $logfile) then
          set LF = $dtdir/scripts/$logfile
          if (-e $LF && ! $AppendLog) mv -f $LF $LF.old
        else
          set LF = $logfile
        endif
      else
        set LF = $dtdir/scripts/trac-all.log
        if (-e $LF && ! $AppendLog) mv -f $LF $LF.old
      endif

      if ($#cmdfile) then
        if (`basename $cmdfile` == $cmdfile) then
          set CF = $dtdir/scripts/$cmdfile
          rm -f $CF
        else
          set CF = $cmdfile
        endif
      else
        set CF = ($dtdir/scripts/trac-all.cmd)
        rm -f $CF
      endif
    endif

    if (-e $LF) then
      printf '\n\n' >> $LF
      echo "New invocation of $ProgName"  >> $LF
      printf '\n\n' >> $LF
    endif
  
    date >> $LF
    pwd >> $LF
    echo $0 >> $LF
    echo $inputargs >> $LF
    echo "Subject $subj" >> $LF
    echo "SUBJECTS_DIR $SUBJECTS_DIR" >> $LF
    echo "FREESURFER_HOME $FREESURFER_HOME" >> $LF
    echo "Actual FREESURFER_HOME $freesurfer_home_true" >> $LF
    if (-e $FREESURFER_HOME/build-stamp.txt) then
      echo "build-stamp.txt: `cat $FREESURFER_HOME/build-stamp.txt`" >> $LF
    endif
    whoami >> $LF
    hostname >> $LF
    uname -a >> $LF
    limit >> $LF
    if (-e /usr/bin/free) then
      echo "" >> $LF
      /usr/bin/free >> $LF
      echo "" >> $LF
    endif
    if ("`uname -s`" == "Darwin") then
      echo "" >> $LF
      /usr/bin/top -l 1 | grep PhysMem >> $LF
      echo "" >> $LF
    endif

    echo "########################################" >> $LF
    echo "Program versions:"		>> $LF
    echo $VERSION               	>> $LF
    mri_convert --all-info		>> $LF
    flirt -version			>> $LF
    bbregister --version		>> $LF
    mri_cvs_register --version		>> $LF
    $trcdir/dmri_motion --all-info	>> $LF
    $trcdir/dmri_train --all-info	>> $LF
    $trcdir/dmri_paths --all-info	>> $LF
    $trcdir/dmri_pathstats --all-info	>> $LF
    $trcdir/dmri_mergepaths --all-info	>> $LF
    $trcdir/dmri_group --all-info	>> $LF

    if ($DoVersionsOnly) continue

    #---------- Check FREESURFER_HOME consistency ---------------------------#

    set CSDF = $dtdir/scripts/csurfdir
    if ($DoCleanCSDF) rm -vf $CSDF
    if (-e $CSDF) then
      set tmp = `cat $CSDF`;
      if ($tmp != $FREESURFER_HOME) then
        echo "INFO: current FREESURFER_HOME does not match" \
             "that of previous processing." | tee -a $LF
        echo "    Current: $FREESURFER_HOME" | tee -a $LF
        echo "    Previous: $tmp" | tee -a $LF
        sleep 1;
      endif
    else
      echo $FREESURFER_HOME > $CSDF
    endif

    # Put a copy of myself (this script) in the scripts dir
    cp $0 $dtdir/scripts/$ProgName.local-copy

    # Write all parameters to local copy of dmrirc
    set RCF = $dtdir/scripts/dmrirc.local
    if (-e $RCF) mv -f $RCF $RCF.orig

    echo "# Run command file generated automatically by $ProgName" 	>> $RCF
    echo "#"							 	>> $RCF
    echo "setenv FREESURFER_HOME $FREESURFER_HOME"			>> $RCF
    echo "setenv SUBJECTS_DIR $SUBJECTS_DIR"				>> $RCF
    echo "set dtroot = ($dtroot)"					>> $RCF
    echo "set subj = ($subj)"						>> $RCF
    echo "#"							 	>> $RCF
    echo "# Processing steps to be performed"			 	>> $RCF
    echo "#"							 	>> $RCF
    echo "set docorr = ($docorr)"					>> $RCF
    echo "set doqa = ($doqa)"						>> $RCF
    echo "set dointra = ($dointra)"					>> $RCF
    echo "set dointer = ($dointer)"					>> $RCF
    echo "set domasks = ($domasks)"					>> $RCF
    echo "set dotensor = ($dotensor)"					>> $RCF
    echo "set dopriors = ($dopriors)"					>> $RCF
    echo "#"							 	>> $RCF
    echo "# Options for image corrections and tensor fit"	 	>> $RCF
    echo "#"							 	>> $RCF
    echo "set dcmroot = ($dcmroot)"					>> $RCF
    echo "set dcmfile = ($dcmlist[$isubj])"				>> $RCF
    if ($#bveclist) then
      echo "set bvecfile = ($bveclist[$isubj])"				>> $RCF
    else
      echo "set bvecfile = ($bvecfile)"					>> $RCF
    endif
    if ($#bvallist) then
      echo "set bvalfile = ($bvallist[$isubj])"				>> $RCF
    else
      echo "set bvalfile = ($bvalfile)"					>> $RCF
    endif
    echo "set nb0 = ($nb0)"						>> $RCF
    echo "set dob0 = ($dob0)"						>> $RCF
    if ($#b0mlist) then
      echo "set b0mfile = ($b0mlist[$isubj])"				>> $RCF
    else
      echo "set b0mfile = ()"						>> $RCF
    endif
    if ($#b0plist) then
      echo "set b0pfile = ($b0plist[$isubj])"				>> $RCF
    else
      echo "set b0pfile = ()"						>> $RCF
    endif
    echo "set echospacing = ($echospacing)"				>> $RCF
    echo "set doeddy = ($doeddy)"					>> $RCF
    echo "set dorotbvecs = ($dorotbvecs)"				>> $RCF
    echo "set thrbet = ($thrbet)"					>> $RCF
    echo "#"							 	>> $RCF
    echo "# Options for registrations"				 	>> $RCF
    echo "#"							 	>> $RCF
    echo "set doregflt = ($doregflt)"					>> $RCF
    echo "set doregbbr = ($doregbbr)"					>> $RCF
    echo "set doregmni = ($doregmni)"					>> $RCF
    echo "set doregcvs = ($doregcvs)"					>> $RCF
    echo "set mnitemp = ($mnitemp)"					>> $RCF
    echo "set cvstempdir = ($cvstempdir)"				>> $RCF
    echo "set cvstemp = ($cvstemp)"					>> $RCF
    echo "#"							 	>> $RCF
    echo "# Options for ball-and-stick model fit"		 	>> $RCF
    echo "#"							 	>> $RCF
    echo "set nstick = ($nstick)"					>> $RCF
    echo "#"							 	>> $RCF
    echo "# Options for path reconstructions"				>> $RCF
    echo "#"							 	>> $RCF
    echo "set usemaskanat = ($usemaskanat)"				>> $RCF
    echo "set pathlist = ($pathlist)"					>> $RCF
    echo "set ncpts = ($ncpts)"						>> $RCF
    echo "set trainsubjlist = ($trainsubjlist)"				>> $RCF
    echo "set ntrainlist = ($ntrainlist)"				>> $RCF
    echo "set avgname = ($avgname)"					>> $RCF
    echo "set reinit = ($reinit)"					>> $RCF
    echo "set usetrunc = ($usetrunc)"					>> $RCF
    echo "set doxyzprior = ($doxyzprior)"				>> $RCF
    echo "set dosegprior = ($dosegprior)"				>> $RCF
    echo "set dotangprior = ($dotangprior)"				>> $RCF
    echo "set dopathsubdirs = ($dopathsubdirs)"				>> $RCF
    echo "set fmin = ($fmin)"						>> $RCF
    echo "set nburnin = ($nburnin)"					>> $RCF
    echo "set nsample = ($nsample)"					>> $RCF
    echo "set nupdate = ($nupdate)"					>> $RCF
    echo "set nkeep = ($nkeep)"						>> $RCF
    echo "set doinitprop = ($doinitprop)"				>> $RCF
    echo "set overwrite = ($overwrite)"					>> $RCF
    echo "#"							 	>> $RCF
    echo "# Location of TRACULA executables"			 	>> $RCF
    echo "#"							 	>> $RCF
    echo "set trcdir = ($trcdir)"					>> $RCF

    if ($dopreproc) then	# Pre-processing #############
      set cmd = trac-preproc
      set cmd = ($cmd -c $RCF)
      set cmd = ($cmd -log $LF)
      set cmd = ($cmd -cmd $CF)
      set cmd = ($cmd $cmdopts)
      if ($#submitfile) then
        echo $cmd >> $submitfile
      else
        echo $cmd
        $cmd
        if ($status) exit 1
      endif
    else if ($dobedpost) then	# Bedpost ####################
      if (! $onpbs) then
        if ($#submitfile) then
          set cmd =  (bedpostx_preproc.sh $dtdir/dmri)
          echo $cmd >> $presubmitfile
          set nslice = `mri_info --nslices $dtdir/dmri/lowb.nii.gz`
          @ islice = 0
          while ($islice < $nslice)
            set cmd = (bedpostx_single_slice.sh $dtdir/dmri)
            set cmd = ($cmd $islice --nf=$nstick --fudge=1 --bi=1000)
            set cmd = ($cmd --nj=1250 --se=25 --model=1 --cnonlinear)
            echo $cmd >> $submitfile
            @ islice = $islice + 1
          end
          set cmd = (bedpostx_postproc.sh $dtdir/dmri)
          echo $cmd >> $postsubmitfile
        else
          echo "WARN: Running bedbostx locally - this might take a while" \
            |& tee -a $LF
          echo "WARN: It is recommended to run this step on a cluster" \
            |& tee -a $LF
          set cmd = (bedpostx_mgh -n $nstick $dtdir/dmri)
          echo $cmd |& tee -a $LF |& tee -a $CF
          if ($RunIt) then
            $cmd |& tee -a $LF
            if ($status) exit 1
          endif
        endif
      endif
    else if ($dopaths) then	# Path reconstruction ########
      set cmd = trac-paths
      set cmd = ($cmd -c $RCF)
      set cmd = ($cmd -log $LF)
      set cmd = ($cmd -cmd $CF)
      set cmd = ($cmd $cmdopts)
      if ($#submitfile) then
        echo $cmd >> $submitfile
      else
        echo $cmd
        $cmd
        if ($status) exit 1
      endif
    endif
  end
else				#--->>> Multiple time points for each subject
  if (! $do1out) then
    # Find which base subjects will be processed
    set bsubjlist = ()

    foreach isubj ($runlist)
      if ($#baselist > 0) then
        set bsubjlist = ($bsubjlist $baselist[$isubj])
      endif
    end

    set bsubjlist = `printf '%s\n' $bsubjlist | sort --unique`
  endif

  # Loop over base subjects
  @ ibsubj = 1
  while ($ibsubj <= $#bsubjlist)
    set bsubj = $bsubjlist[$ibsubj]

    if ($do1out) then
      set dtdir = $bsubj
      set dtroot = `dirname $dtdir`
      set bsubj = `basename $dtdir`

      if (-e $trainfile) then
        set trainsubjlist = `cat $trainfile | sed -n "$ibsubj p"`
        shift trainsubjlist
      endif
    else
      set dtdir = $dtroot/$bsubj

      if (-e $trainfile) then
        set trainsubjlist = `cat $trainfile`
      endif
    endif

    # Find which time points will be processed for this base subject
    set itps = ()
    set tplist = ()

    foreach isubj ($runlist)
      if ($baselist[$isubj] == $bsubj) then
        set itps = ($itps $isubj)
        set tplist = ($tplist $subjlist[$isubj])
      endif
    end

    set tplist = `printf "%s.long.$bsubj " $tplist`

    # Depending on which step of the analysis I am preforming,
    # I may need to process the time points, the base, or all of the above
    set proclist = ()

    if ($dopreproc) then
      set proclist = ($tplist $bsubj)
    else if ($dobedpost || $dostats) then
      set proclist = ($tplist)
    else if ($dopaths) then
      set proclist = ($bsubj)
    endif

    set LFlist = ()
    set CFlist = ()
    set RCFlist = ()

    @ iproc = 1
    while ($iproc <= $#proclist)
      set subj = $proclist[$iproc]

      set dtdir = $dtroot/$subj

      if ($subj != $bsubj) then
        set subjdirs = ($subjdirs $dtdir)
        set basedirs = ($basedirs $dtroot/$bsubj)
      endif

      if ($dostats) then
        @ iproc = $iproc + 1
        continue
      endif

      if (($dointra || $dointer || $domasks) && ! $do1out) then
        # Check freesurfer directory
        set fsdir = $SUBJECTS_DIR/$subj

        if (! -e $fsdir) then
          echo "ERROR: cannot find $fsdir"
          exit 1
        endif

        if (! -r $fsdir) then
          echo "ERROR: $fsdir exists but is unreadable"
          exit 1
        endif
      endif

      mkdir -p $dtdir/scripts

      # Check diffusion directory
      if (! -w $dtdir) then
        echo "ERROR: cannot write in $dtdir"
        exit 1
      endif

      #---------- Check build stamp -------------------------------------------#
      # This allows the user to require that the build stamp be
      # consistent from one trac-all/recon-all invocation to the next.
      # Good for frozen versions.

      if ($?REQUIRE_FS_MATCH == 0) setenv REQUIRE_FS_MATCH 0

      set bstampfile0 = $FREESURFER_HOME/build-stamp.txt
      set bstampfile  = $dtdir/scripts/build-stamp.txt

      if (-e $bstampfile0) then
        if (! -e $bstampfile) cp $bstampfile0 $bstampfile

        set bstamp0 = `cat $bstampfile0`
        set bstamp  = `cat $bstampfile`

        if ("$bstamp0" != "$bstamp") then
          if ($REQUIRE_FS_MATCH) then
            echo "ERROR: FreeSurfer build stamps do not match"
            echo "Subject Stamp: $bstamp"
            echo "Current Stamp: $bstamp0"
            exit 1;
          else
            echo "INFO: FreeSurfer build stamps do not match"
            echo "Subject Stamp: $bstamp"
            echo "Current Stamp: $bstamp0"
          endif
        endif
      endif

      #---------- Create log and command files --------------------------------#

      if ($DoVersionsOnly) then
        if (-e /dev/stdout) then
          set LF = /dev/stdout
        else
          set LF = /dev/null
        endif
      else
        if ($#logfile) then
          if (`basename $logfile` == $logfile) then
            set LF = $dtdir/scripts/$logfile
            if (-e $LF && ! $AppendLog) mv -f $LF $LF.old
          else
            set LF = $logfile
          endif
        else
          set LF = ($dtdir/scripts/trac-all.log)
          if (-e $LF && ! $AppendLog) mv -f $LF $LF.old
        endif

        if ($#cmdfile) then
          if (`basename $cmdfile` == $cmdfile) then
            set CF = $dtdir/scripts/$cmdfile
            rm -f $CF
          else
            set CF = $cmdfile
          endif
        else
          set CF = ($dtdir/scripts/trac-all.cmd)
          rm -f $CF
        endif
      endif

      if (-e $LF) then
        printf '\n\n' >> $LF
        echo "New invocation of $ProgName"  >> $LF
        printf '\n\n' >> $LF
      endif
  
      date >> $LF
      pwd >> $LF
      echo $0 >> $LF
      echo $inputargs >> $LF
      echo "Subject $subj" >> $LF
      echo "SUBJECTS_DIR $SUBJECTS_DIR" >> $LF
      echo "FREESURFER_HOME $FREESURFER_HOME" >> $LF
      echo "Actual FREESURFER_HOME $freesurfer_home_true" >> $LF
      if (-e $FREESURFER_HOME/build-stamp.txt) then
        echo "build-stamp.txt: `cat $FREESURFER_HOME/build-stamp.txt`" >> $LF
      endif
      whoami >> $LF
      hostname >> $LF
      uname -a >> $LF
      limit >> $LF
      if (-e /usr/bin/free) then
        echo "" >> $LF
        /usr/bin/free >> $LF
        echo "" >> $LF
      endif
      if ("`uname -s`" == "Darwin") then
        echo "" >> $LF
        /usr/bin/top -l 1 | grep PhysMem >> $LF
        echo "" >> $LF
      endif

      echo "########################################" >> $LF
      echo "Program versions:"			>> $LF
      echo $VERSION               		>> $LF
      mri_convert --all-info			>> $LF
      flirt -version				>> $LF
      bbregister --version			>> $LF
      mri_cvs_register --version		>> $LF
      $trcdir/dmri_train --all-info		>> $LF
      $trcdir/dmri_paths --all-info		>> $LF
      $trcdir/dmri_pathstats --all-info		>> $LF
      $trcdir/dmri_mergepaths --all-info	>> $LF
      $trcdir/dmri_group --all-info		>> $LF

      if ($DoVersionsOnly) continue

      #---------- Check FREESURFER_HOME consistency ---------------------------#

      set CSDF = $dtdir/scripts/csurfdir
      if ($DoCleanCSDF) rm -vf $CSDF
      if (-e $CSDF) then
        set tmp = `cat $CSDF`;
        if ($tmp != $FREESURFER_HOME) then
          echo "INFO: current FREESURFER_HOME does not match" \
               "that of previous processing." | tee -a $LF
          echo "    Current: $FREESURFER_HOME" | tee -a $LF
          echo "    Previous: $tmp" | tee -a $LF
          sleep 1;
        endif
      else
        echo $FREESURFER_HOME > $CSDF
      endif

      # Put a copy of myself (this script) in the scripts dir
      cp $0 $dtdir/scripts/$ProgName.local-copy

      # Write all parameters to local copy of dmrirc
      set RCF = $dtdir/scripts/dmrirc.local
      if (-e $RCF) mv -f $RCF $RCF.orig

      echo "# Run command file generated automatically by $ProgName" 	>> $RCF
      echo "#"							 	>> $RCF
      if ($subj == $bsubj) then
        echo "# This is a base template for longitudinal tractography"	>> $RCF
        echo "set tplist = ($tplist)"					>> $RCF
      else
        echo "# This is a time point for longitudinal tractography"	>> $RCF
      endif
      echo "#"							 	>> $RCF
      echo "setenv FREESURFER_HOME $FREESURFER_HOME"			>> $RCF
      echo "setenv SUBJECTS_DIR $SUBJECTS_DIR"				>> $RCF
      echo "set dtroot = ($dtroot)"					>> $RCF
      echo "set subj = ($subj)"						>> $RCF
      echo "#"							 	>> $RCF
      echo "# Processing steps to be performed"			 	>> $RCF
      echo "#"							 	>> $RCF
      if ($subj == $bsubj) then
        echo "set docorr = (0)"						>> $RCF
        echo "set doqa = (0)"						>> $RCF
        echo "set dointra = (0)"					>> $RCF
      else
        echo "set docorr = ($docorr)"					>> $RCF
        echo "set doqa = ($doqa)"					>> $RCF
        echo "set dointra = ($dointra)"					>> $RCF
      endif
      echo "set dointer = ($dointer)"					>> $RCF
      echo "set domasks = ($domasks)"					>> $RCF
      if ($subj == $bsubj) then
        echo "set dotensor = (0)"					>> $RCF
        echo "set dopriors = ($dopriors)"				>> $RCF
      else
        echo "set dotensor = ($dotensor)"				>> $RCF
        echo "set dopriors = (0)"					>> $RCF
      endif
      echo "#"							 	>> $RCF
      echo "# Options for image corrections and tensor fit"	 	>> $RCF
      echo "#"							 	>> $RCF
      echo "set dcmroot = ($dcmroot)"					>> $RCF
      if ($subj != $bsubj) then
        echo "set dcmfile = ($dcmlist[$itps[$iproc]])"			>> $RCF
      else
        echo "set dcmfile = ()"						>> $RCF
      endif
      if ($#bveclist && $subj != $bsubj) then
        echo "set bvecfile = ($bveclist[$itps[$iproc]])"		>> $RCF
      else
        echo "set bvecfile = ($bvecfile)"				>> $RCF
      endif
      if ($#bvallist && $subj != $bsubj) then
        echo "set bvalfile = ($bvallist[$itps[$iproc]])"		>> $RCF
      else
        echo "set bvalfile = ($bvalfile)"				>> $RCF
      endif
      echo "set nb0 = ($nb0)"						>> $RCF
      echo "set dob0 = ($dob0)"						>> $RCF
      if ($subj != $bsubj && $#b0mlist) then
        echo "set b0mfile = ($b0mlist[$itps[$iproc]])"			>> $RCF
      else
        echo "set b0mfile = ()"						>> $RCF
      endif
      if ($subj != $bsubj && $#b0plist) then
        echo "set b0pfile = ($b0plist[$itps[$iproc]])"			>> $RCF
      else
        echo "set b0pfile = ()"						>> $RCF
      endif
      echo "set echospacing = ($echospacing)"				>> $RCF
      echo "set doeddy = ($doeddy)"					>> $RCF
      echo "set dorotbvecs = ($dorotbvecs)"				>> $RCF
      echo "set thrbet = ($thrbet)"					>> $RCF
      echo "set usemaskanat = ($usemaskanat)"				>> $RCF
      echo "#"							 	>> $RCF
      echo "# Options for registrations"			 	>> $RCF
      echo "#"							 	>> $RCF
      echo "set doregflt = ($doregflt)"					>> $RCF
      echo "set doregbbr = ($doregbbr)"					>> $RCF
      echo "set doregmni = ($doregmni)"					>> $RCF
      echo "set doregcvs = ($doregcvs)"					>> $RCF
      echo "set mnitemp = ($mnitemp)"					>> $RCF
      echo "set cvstempdir = ($cvstempdir)"				>> $RCF
      echo "set cvstemp = ($cvstemp)"					>> $RCF
      echo "#"							 	>> $RCF
      echo "# Options for ball-and-stick model fit"		 	>> $RCF
      echo "#"							 	>> $RCF
      echo "set nstick = ($nstick)"					>> $RCF
      echo "#"						 		>> $RCF
      echo "# Options for path reconstructions"				>> $RCF
      echo "#"							 	>> $RCF
      echo "set pathlist = ($pathlist)"					>> $RCF
      echo "set ncpts = ($ncpts)"					>> $RCF
      echo "set trainsubjlist = ($trainsubjlist)"			>> $RCF
      echo "set ntrainlist = ($ntrainlist)"				>> $RCF
      echo "set avgname = ($avgname)"					>> $RCF
      echo "set reinit = ($reinit)"					>> $RCF
      echo "set usetrunc = ($usetrunc)"					>> $RCF
      echo "set doxyzprior = ($doxyzprior)"				>> $RCF
      echo "set dosegprior = ($dosegprior)"				>> $RCF
      echo "set dotangprior = ($dotangprior)"				>> $RCF
      echo "set dopathsubdirs = ($dopathsubdirs)"			>> $RCF
      echo "set fmin = ($fmin)"						>> $RCF
      echo "set nburnin = ($nburnin)"					>> $RCF
      echo "set nsample = ($nsample)"					>> $RCF
      echo "set nupdate = ($nupdate)"					>> $RCF
      echo "set nkeep = ($nkeep)"					>> $RCF
      echo "set doinitprop = ($doinitprop)"				>> $RCF
      echo "set overwrite = ($overwrite)"				>> $RCF
      echo "#"							 	>> $RCF
      echo "# Location of TRACULA executables"			 	>> $RCF
      echo "#"							 	>> $RCF
      echo "set trcdir = ($trcdir)"					>> $RCF

      set LFlist  = ($LFlist $LF)
      set CFlist  = ($CFlist $CF)
      set RCFlist = ($RCFlist $RCF)

      @ iproc = $iproc + 1
    end

    if ($dopreproc) then	# Pre-processing #############
      set cmd = ()
      @ iproc = 1
      while ($iproc <= $#proclist)
        set cmd = ($cmd trac-preproc)
        set cmd = ($cmd -c $RCFlist[$iproc])
        set cmd = ($cmd -log $LFlist[$iproc])
        set cmd = ($cmd -cmd $CFlist[$iproc])
        set cmd = ($cmd $cmdopts;)
        @ iproc = $iproc + 1
      end
      if ($#submitfile) then
        echo $cmd >> $submitfile
      else
        echo $cmd
        /bin/tcsh -fc "$cmd"
        if ($status) exit 1
      endif
    else if ($dobedpost) then	# Bedpost ####################
      @ iproc = 1
      while ($iproc <= $#proclist)
        if (! $onpbs) then
          if ($#submitfile) then
            set cmd =  (bedpostx_preproc.sh $dtroot/$proclist[$iproc]/dmri)
            echo $cmd >> $presubmitfile
            set nslice = `mri_info --nslices \
                          $dtroot/$proclist[$iproc]/dmri/lowb.nii.gz`
            @ islice = 0
            while ($islice < $nslice)
              set cmd = (bedpostx_single_slice.sh $dtroot/$proclist[$iproc]/dmri)
              set cmd = ($cmd $islice --nf=$nstick --fudge=1 --bi=1000)
              set cmd = ($cmd --nj=1250 --se=25 --model=1 --cnonlinear)
              echo $cmd >> $submitfile
              @ islice = $islice + 1
            end
            set cmd = (bedpostx_postproc.sh $dtroot/$proclist[$iproc]/dmri)
            echo $cmd >> $postsubmitfile
          else
            echo "WARN: Running bedbostx locally - this might take a while" \
              |& tee -a $LFlist[$iproc]
            echo "WARN: It is recommended to run this step on a cluster" \
              |& tee -a $LFlist[$iproc]
            set cmd = (bedpostx_mgh -n $nstick $dtroot/$proclist[$iproc]/dmri)
            echo $cmd |& tee -a $LFlist[$iproc] |& tee -a $CFlist[$iproc]
            if ($RunIt) then
              $cmd |& tee -a $LFlist[$iproc]
              if ($status) exit 1
            endif
          endif
        endif
        @ iproc = $iproc + 1
      end
    else if ($dopaths) then	# Path reconstruction ########
      set cmd = trac-paths
      set cmd = ($cmd -c $RCF)
      set cmd = ($cmd -log $LF)
      set cmd = ($cmd -cmd $CF)
      set cmd = ($cmd $cmdopts)
      if ($#submitfile) then
        echo $cmd >> $submitfile
      else
        echo $cmd
        /bin/tcsh -fc "$cmd"
        if ($status) exit 1
      endif
    endif

    @ ibsubj = $ibsubj + 1
  end
endif

if ($dostats) then
  # Check root diffusion directory
  if (! -w $dtroot) then
    echo "ERROR: cannot write in $dtroot"
    exit 1
  endif

  if ($#baselist == 0) then
    set statdir = $dtroot/stats
  else
    set statdir = $dtroot/stats.long
  endif

  if ($RunIt) then
    mkdir -p $statdir
  endif

  set cvswarp = final_CVSmorph_to$cvstemp

  set xspacelist = ()
  if ($doregmni) set xspacelist = ($xspacelist mni)
  if ($doregcvs) set xspacelist = ($xspacelist cvs)

  set reglist = ()
  if ($doregflt) set reglist = ($reglist flt)
  if ($doregbbr) set reglist = ($reglist bbr)

  foreach ntrain ($ntrainlist)
    foreach xspace ($xspacelist)
      foreach reg ($reglist)
        set outdir = dpath

        if ($dopathsubdirs) then
          set outdir = $outdir/${nsample}samp

          set ptype = ()

          if ($dosegprior) then
            set ptype = seg14
          endif
          if ($dotangprior) then
            if ($#ptype) then
              set ptype = $ptype.tang
            else
              set ptype = tang
            endif
          endif
          if ($doxyzprior) then
            if ($#ptype) then
              set ptype = $ptype.xyz
            else
              set ptype = xyz
            endif
          endif
          if (! $#ptype) then
            set ptype = none
          endif

          set outdir = $outdir/$ptype
        endif

        set avgmode = $avgname${ntrain}_${xspace}_$reg

        foreach pathname ($pathlist)
          if ($RunIt) then
            rm -f $statdir/$pathname.$avgmode.inputs.txt

            @ k = 1
            while ($k <= $#subjdirs)
              set pathdir = $subjdirs[$k]/$outdir/${pathname}_$avgmode

              if (-e $pathdir/path.pd.nii.gz) then
                if ($#baselist == 0) then		# Cross-sectional
                  set xfmdir = $subjdirs[$k]/dmri/xfms
                  set labdir = $subjdirs[$k]/dlabel
                  set refvol = $labdir/diff/aparc+aseg_mask.$reg.nii.gz
                else					# Longitudinal
                  set xfmdir = $basedirs[$k]/dmri/xfms
                  set labdir = $basedirs[$k]/dlabel
                  set refvol = $labdir/anatorig/aparc+aseg_mask.nii.gz
                endif

                set inputs = ($pathdir $refvol)

                if ($xspace == mni) then
                  if ($#baselist == 0) then		# Cross-sectional
                    set inputs = ($inputs $xfmdir/diff2mni.$reg.mat)
                  else					# Longitudinal
                    set inputs = ($inputs $xfmdir/anatorig2mni.mat)
                  endif
                else if ($xspace == cvs) then
                  if ($#baselist == 0) then		# Cross-sectional
                    set inputs = ($inputs $xfmdir/diff2anatorig.$reg.mat)
                    if (-e $xfmdir/cvs/$cvswarp.m3z) then
                      set inputs = ($inputs $xfmdir/cvs/$cvswarp.m3z)
                    endif
                  else					# Longitudinal
                    if (-e $xfmdir/cvs/$cvswarp.m3z) then
                      set inputs = ($inputs $xfmdir/cvs/$cvswarp.m3z)
                    endif
                  endif
                endif

                echo $inputs >> $statdir/$pathname.$avgmode.inputs.txt
              endif

              @ k = $k + 1
            end

            if (! -e $statdir/$pathname.$avgmode.inputs.txt) then
              echo "ERROR: no pathway reconstructions found"
              exit 1
            endif
          endif

          set cmd = $trcdir/dmri_group
          set cmd = ($cmd --list  $statdir/$pathname.$avgmode.inputs.txt)
          if ($xspace == mni) then
            set cmd = ($cmd --ref $mnitemp)
          else if ($xspace == cvs) then
            set cmd = ($cmd --ref $cvstempdir/$cvstemp/mri/norm.mgz)
          endif
          set cmd = ($cmd --out   $statdir/$pathname.$avgmode)

          set LF = $statdir/$pathname.$avgmode.log

          if ($RunIt) then
            if ($#submitfile) then
              echo "$cmd |& tee -a $LF" >> $submitfile
            else
              echo $cmd
              $cmd |& tee -a $LF
              if ($status) exit 1
            endif
          endif
        end
      end
    end
  end
endif

if ($onpbs && $RunIt) then
  if (! $?MYPBSMAXJOBS) setenv MYPBSMAXJOBS 30

  if ($dopreproc) then
    if (! $?MYPBSWAIT) setenv MYPBSWAIT 30
    if ($doregcvs) setenv MYPBSARCH "ppn=4,vmem=28gb"
    echo Queueing pre-processing
    set preid = `fsl_sub_mgh -l $pbslogdir/log -m a -N trcpre -t $submitfile`
  else if ($dobedpost) then
    if (! $?MYPBSWAIT) setenv MYPBSWAIT 0
    bedpostx_mgh -n $nstick `printf '%s/dmri ' $subjdirs`
  else if ($dopaths) then
    if (! $?MYPBSWAIT) setenv MYPBSWAIT 30
    if ($doregcvs) setenv MYPBSARCH "ppn=4,vmem=28gb"
    echo Queueing path reconstruction
    set trcid = `fsl_sub_mgh -l $pbslogdir/log -m a -N trc -t $submitfile`
  else if ($dostats) then
    if (! $?MYPBSWAIT) setenv MYPBSWAIT 30
    if ($doregcvs) setenv MYPBSARCH "ppn=4,vmem=28gb"
    echo Queueing group tables
    set grpid = `fsl_sub_mgh -l $pbslogdir/log -m a -N trcgrp -t $submitfile`
  endif
endif

# Add to usage tracking file, if configured and writable
# A sysadmin would need to have users set the environment var
# TRACALL_USAGE_FILE to a world-writable file. Example: 
# setenv TRACALL_USAGE_FILE /space/freesurfer/trac-all_run_log
if ($?TRACALL_USAGE_FILE) then
  if (-e $TRACALL_USAGE_FILE) then
    if (-w $TRACALL_USAGE_FILE) then
      if ($RunIt) then
        echo "`date` `cat $FREESURFER_HOME/build-stamp.txt`" \
          >> $TRACALL_USAGE_FILE
        endif
      endif
  endif
endif

exit 0
#############------------------------------------#######################
##################>>>>>>>>>>>>>.<<<<<<<<<<<<<<<<<#######################
#############------------------------------------#######################

############--------------##################
parse_args:
set cmdline = ($argv)

while( $#argv != 0 )
  set flag = $argv[1]; shift;

  switch($flag)
    case "-subject":
    case "-subjid":
    case "-sid":
    case "-s":
      if ($#argv < 1) goto arg1err;
      set subjlist = $argv[1]; shift;
      set subjlist = `basename $subjlist`	# to remove trailing /
      breaksw

    case "-i":
      if ($#argv < 1) goto arg1err;
      set dcmlist = "$argv[1]"; shift;
      if (! -e "$dcmlist") then
        echo "ERROR: cannot find $dcmlist"
        exit 1
      endif
      if (! -r "$dcmlist") then
        echo "ERROR: $dcmlist exists but is not readable"
        exit 1
      endif
      set dcmroot = `dirname  "$dcmlist"`
      set dcmlist = `basename "$dcmlist"`
      breaksw

    case "-c":
      if ($#argv < 1) goto arg1err;
      set rcfile = "$argv[1]"; shift;
      if (! -e "$rcfile") then
        echo "ERROR: cannot find $rcfile"
        exit 1
      endif
      if (! -r "$rcfile") then
        echo "ERROR: $rcfile exists but is not readable"
        exit 1
      endif
      breaksw

    case "-prep":
      set dopreproc = 1
      set docorr = 1
      set doqa = 1
      set dointra = 1
      set dointer = 1
      set domasks = 1
      set dotensor = 1
      set dopriors = 1
      set dobedpost = 0
      set dopaths = 0
      set dostats = 0
      breaksw

    case "-bedp":
      set dopreproc = 0
      set dobedpost = 1
      set dopaths = 0
      set dostats = 0
      breaksw

    case "-path":
      set dopreproc = 0
      set dobedpost = 0
      set dopaths = 1
      set dostats = 0
      breaksw

    case "-stat":
      set dopreproc = 0
      set dobedpost = 0
      set dopaths = 0
      set dostats = 1
      breaksw

    case "-corr":
      set dopreproc = 1
      set docorr = 1
      set dobedpost = 0
      set dopaths = 0
      set dostats = 0
      breaksw

    case "-nocorr":
      set docorr = 0
      breaksw

    case "-qa":
      set dopreproc = 1
      set doqa = 1
      set dobedpost = 0
      set dopaths = 0
      set dostats = 0
      breaksw

    case "-noqa":
      set doqa = 0
      breaksw

    case "-intra":
      set dopreproc = 1
      set dointra = 1
      set dobedpost = 0
      set dopaths = 0
      set dostats = 0
      breaksw

    case "-nointra":
      set dointra = 0
      breaksw

    case "-inter":
      set dopreproc = 1
      set dointer = 1
      set dobedpost = 0
      set dopaths = 0
      set dostats = 0
      breaksw

    case "-nointer":
      set dointer = 0
      breaksw

    case "-masks":
      set dopreproc = 1
      set domasks = 1
      set dobedpost = 0
      set dopaths = 0
      set dostats = 0
      breaksw

    case "-nomasks":
      set domasks = 0
      breaksw

    case "-tensor":
      set dopreproc = 1
      set dotensor = 1
      set dobedpost = 0
      set dopaths = 0
      set dostats = 0
      breaksw

    case "-notensor":
      set dotensor = 0
      breaksw

    case "-prior":
      set dopreproc = 1
      set dopriors = 1
      set dobedpost = 0
      set dopaths = 0
      set dostats = 0
      breaksw

    case "-noprior":
      set dopriors = 0
      breaksw

    case "-cleancsdf":
      set DoCleanCSDF = 1
      breaksw

    case "-time":
      set DoTime = 1
      breaksw

    case "-notime":
      set DoTime = 0
      breaksw

    case "-noappendlog":
      set AppendLog = 0
      breaksw

    case "-jobs":
      if ($#argv < 1) goto arg1err;
      set submitfile = $argv[1]; shift;
      breaksw

    case "-log":
      if ($#argv < 1) goto arg1err;
      set logfile = $argv[1]; shift;
      breaksw

    case "-cmd":
      if ($#argv < 1) goto arg1err;
      set cmdfile = $argv[1]; shift;
      breaksw

    case "-no-isrunning":
      set DoIsRunning = 0
      breaksw

    case "-sd":
      if ($#argv < 1) goto arg1err;
      setenv SUBJECTS_DIR $argv[1]; shift;
      breaksw

    case "-csurfdir":
      if ($#argv < 1) goto arg1err;
      setenv FREESURFER_HOME $argv[1]; shift;
      if (! -e $FREESURFER_HOME) then
        echo "ERROR: cannot find $FREESURFER_HOME"
        exit 1
      endif
      pushd $FREESURFER_HOME > /dev/null
      setenv FREESURFER_HOME `pwd`;
      breaksw

    case "-umask":
      if ($#argv < 1) goto arg1err;
      set umaskid = $1;
      umask $1; shift;
      breaksw

    case "-grp":
      if ($#argv < 1) goto arg1err;
      set groupid = $argv[1];
      set curgrp = `id -gn`;
      if ($groupid != $curgrp) then
        echo "ERROR: current group $curgrp and specified group $groupid differ"
        exit 1
      endif
      breaksw

    case "-allowcoredump":
      set allowcore = 1
      limit coredumpsize unlimited
      breaksw

    case "-debug":
      set debug = 1
      breaksw

    case "-dontrun":
      set RunIt = 0
      breaksw

    case "-onlyversions":
      set DoVersionsOnly = 1
      breaksw

    default:
      echo "ERROR: flag $flag unrecognized"
      echo $cmdline
      exit 1
      breaksw
  endsw
end

goto parse_args_return;

############--------------##################
arg1err:
  echo "ERROR: flag $flag requires one argument"
  exit 1

############--------------##################
check_params:
  if (! $DoVersionsOnly) then
    if (-e $trainfile) then
      if ($do1out) then
        # Leave-one-out training file:
        # The first subject of each line is the test subject,
        # the remaining subjects of the line are the training subjects
        if ($#baselist == 0) then	# A single time point for each subject
          set subjlist = `cat $trainfile | awk '{print $1}'`

          set runlist = 1
          while ($runlist[$#runlist] < $#subjlist)
            set runlist = ($runlist `echo $runlist[$#runlist] + 1 | bc`)
          end
        else				# Multiple time points for each subject
          set bsubjlist = `cat $trainfile | awk '{print $1}'`
        endif

        if (! $#ntrainlist) then
          set ntrainlist = `head -1 $trainfile | wc -w | awk '{print $1 - 1}'`
        endif
      else
        # Simple training file:
        # The file lists the training subjects
        # Info on the test subjects comes from dmrirc
        set ntrainlist = `wc -w $trainfile | awk '{print $1}'`
      endif
    else if ($dopriors || $dopaths) then
      echo "ERROR: Cannot find list of training subjects $trainfile"
      exit 1
    endif

    if (! $#avgname) then
      set avgname = avg
    endif

    if (! $?subjlist) then
      echo "ERROR: must specify a subject id"
      exit 1
    endif

    if ($#runlist == 0) then			# Process all subjects
      set runlist = 1
      while ($runlist[$#runlist] < $#subjlist)
        set runlist = ($runlist `echo $runlist[$#runlist] + 1 | bc`)
      end
    else
      foreach isubj ($runlist)
        if ($isubj > $#subjlist) then
          echo "ERROR: $isubj is in run list but have only $#subjlist subjects"
          exit 1
        endif
      end
    endif

    if (! $?SUBJECTS_DIR) then
      echo "ERROR: environment variable SUBJECTS_DIR not set"
      echo "  this can be done by setting it in the shell before"
      echo "  executing trac-all or by using the -sd flag"
      exit 1
    endif

    if (! -e $SUBJECTS_DIR) then
      echo "ERROR: SUBJECTS_DIR $SUBJECTS_DIR does not exist."
      exit 1
    endif

    # Get the full path #
    pushd $SUBJECTS_DIR > /dev/null
    setenv SUBJECTS_DIR `pwd`;
    popd > /dev/null

    if (! $#dtroot) then		# Save output under SUBJECTS_DIR
      set dtroot = $SUBJECTS_DIR
    endif

    if ($#ncpts > 1 && $#ncpts != $#pathlist) then
      echo "ERROR: must specify either one number of control points"
      echo "ERROR: or as many numbers as pathways"
      exit 1
    endif

    foreach n ($ncpts)
      if ($n < 2) then
        echo "ERROR: number of control points cannot be less than 2"
        exit 1
      endif
    end

    if ($#runlist > $#subjlist) then
      echo "ERROR: run list is longer than subject list"
      exit 1
    endif

    if ($docorr) then
      if ($#dcmlist != $#subjlist) then
        echo "ERROR: must specify as many DWI dicoms as subjects"
        exit 1
      endif

      if ($#bveclist > 0 && $#bveclist != $#subjlist) then
        echo "ERROR: must specify as many gradient vector tables as subjects"
        exit 1
      endif

      if ($#bvallist > 0 && $#bvallist != $#subjlist) then
        echo "ERROR: must specify as many b-value tables as subjects"
        exit 1
      endif

      if ($#b0mlist > 0 && $#b0mlist != $#subjlist) then
        echo "ERROR: must specify as many fieldmap magnitude dicoms as subjects"
        exit 1
      endif

      if ($#b0plist > 0 && $#b0plist != $#subjlist) then
        echo "ERROR: must specify as many fieldmap phase dicoms as subjects"
        exit 1
      endif
    endif

    if ($#baselist > 0 && $#baselist != $#subjlist) then
      echo "ERROR: must specify a base template name for every time point name"
      exit 1
    endif
  endif

  if (! $?FREESURFER_HOME) then
    echo "ERROR: environment variable FREESURFER_HOME not set."
    exit 1
  endif

  if (! -e $FREESURFER_HOME) then
    echo "ERROR: FREESURFER_HOME $FREESURFER_HOME does not exist."
    exit 1
  endif

  if ((! $dopreproc || (! $docorr && ! $doqa && ! $dointra && ! $dointer && \
                        ! $domasks && ! $dotensor && ! $dopriors)) && \
       ! $dobedpost && ! $dopaths && ! $dostats) then
    echo "ERROR: no analysis step (-{prep,bedp,path,stat}) has been selected"
    exit 1
  endif

goto check_params_return;

############--------------##################
usage_exit:
  echo ""
  echo "USAGE: $ProgName"
  echo ""
  echo "Using a configuration file to set analysis options:"
  echo "  -c <file> : dmrirc file (see dmrirc.example)"
  echo ""
  echo "Using only mandatory inputs with all default options:"
  echo "  -s <subjectname> : subject name (if not defined in dmrirc)"
  echo "  -i <file> : input DWI DICOM (if not defined in dmrirc)"
  echo ""
  echo "Choosing which part of the analysis to do:"
  echo "  -prep     : do pre-processing (step 1, all substeps)"
  echo "  -bedp     : do bedpost (step 2)"
  echo "  -path     : do pathway reconstruction (step 3)"
  echo "  -stat     : assemble pathway measures from multiple subjects (step 4)"
  echo ""
  echo "Performing a part of the preprocessing or skipping a part:"
  echo "  -corr     : do image corrections (step 1.1)"
  echo "  -nocorr   : don't do step 1.1"
  echo "  -qa       : do image quality assessment (step 1.2)"
  echo "  -noqa     : don't do step 1.2"
  echo "  -intra    : do intra-subject registration (step 1.3)"
  echo "  -nointra  : don't do step 1.3"
  echo "  -inter    : do inter-subject registration (step 1.4)"
  echo "  -nointer  : don't do step 1.4"
  echo "  -masks    : do masks (step 1.5)"
  echo "  -nomasks  : don't do step 1.5"
  echo "  -tensor   : do tensor fit (step 1.6)"
  echo "  -notensor : don't do step 1.6"
  echo "  -prior    : do pathway priors (step 1.7)"
  echo "  -noprior  : don't do step 1.7"
  echo ""
  echo "Analysis steps:"
  echo "  1. Pre-processing"
  echo "     1.1 Image corrections (eddy-current and/or B0)"
  echo "     1.2 Image quality assessment (head motion measures)"
  echo "     1.3 Intra-subject registration (diffusion to T1)"
  echo "     1.4 Inter-subject registration (T1 to template)"
  echo "     1.5 White-matter, cortical, and whole-brain masks"
  echo "     1.6 Tensor fit"
  echo "     1.7 Pathway priors from atlas and T1"
  echo "  2. Stick-and-ball model fitting with bedpost"
  echo "  3. Pathway reconstruction"
  echo "  4. Assemble pathway measures from all subjects"
  echo ""
  echo "Other options:"
  echo "  -jobs <file>    : write a text file with command lines that can be"
  echo "                    run in parallel but do not run them - the user can"
  echo "                    then submit each line as a job on a compute cluster"
  echo "  -log <file>     : unique log file instead of scripts/trac-all.log"
  echo "  -noappendlog    : overwrite old log files instead of appending"
  echo "  -cmd <file>     : unique cmd file instead of scripts/trac-all.cmd"
  echo "  -no-isrunning   : do not check whether subjects are currently being processed"
  echo "  -sd subjectsdir : specify subjects dir (default env SUBJECTS_DIR)"
  echo "  -umask umask    : set unix file permission mask (default 002)"
  echo "  -grp groupid    : check that current group is alpha groupid "
  echo "  -allowcoredump  : set coredump limit to unlimited"
  echo "  -debug          : generate much more output"
  echo "  -dontrun        : do everything but execute each command"
  echo "  -onlyversions   : print version of each binary and exit"
  echo "  -version        : print version of this script and exit"
  echo "  -help           : print full contents of help"
  echo ""

  if (! $PrintHelp) exit 1

  echo $VERSION
  echo ""

  cat $0 | awk 'BEGIN{prt=0}{if(prt) print $0; if($1 == "BEGINHELP") prt=1}'

  exit 1

#---- Everything below here is printed out as part of help -----#
BEGINHELP

Recostruct white-matter pathways using an atlas of the underlying anatomy.

BASIC USAGE
There are two ways to use this script.

> Using only mandatory inputs with all default options:
  trac-all -{prep,bedp,path,stat} -subject subjectname -i dicomfile

> Using a file called dmrirc to define custom options:
  trac-all -{prep,bedp,path,stat} -c dmrirc

If a dmrirc file is not specified, then the subject name and input DWI
DICOM must be specified on the command line. If a dmrirc file is specified,
then the options set in that file override any corresponding command line
options.

STEP-WISE DIRECTIVES
Any of the two basic forms of usage described above must include an
argument (-prep for pre-processing, -bedp for bedpost, -path for path
reconstruction, or -stat for group tables) that specifies which part of
the analysis to perform. The four parts must be performed in that order.

It is also possible to perform a certain step of the pre-processing
(with -stepname) or to skip a certain step from the pre-processing (with
-nostepname). The default pre-processing performs all steps.

If there are conflicting step-wise arguments, the ones that come later
in the command line override the ones that come earlier.

Various aspects of each processing step can be configured in the dmrirc
file. See dmrirc.example for more details.

> Step 1: Pre-processing
          -prep to do this step

  Pre-processing includes steps 1.1 through 1.5 below.

> Step 1.1: Image corrections
            -corr to do this step, -nocorr to skip this step

  Eddy current correction with eddy_correct, B0 field map correction with
  epidewarp.fsl.

> Step 1.2: Image quality assessment
            -qa to do this step, -noqa to skip this step

  Estimation of between-volume and within-volume head motion.

> Step 1.3: Intra-subject registration
            -intra to do this step, -nointra to skip this step

  Diffusion-to-T1 registration with flirt and/or bbregister.

> Step 1.4: Inter-subject registration
            -inter to do this step, -nointer to skip this step

  T1-to-template registration using MNI and/or CVS templates.

> Step 1.5: White-matter, cortical, and whole-brain masks
            -masks to do this step, -nomasks to skip this step

  Generate masks of the white matter and cortex from FreeSurfer outputs,
  whole-brain masks from T1 and DWIs.

> Step 1.6: Tensor fit
            -tensor to do this step, -notensor to skip this step

  Tensor model fitting on DWIs.

> Step 1.7: Pathway priors
            -prior to do this step, -noprior to skip this step

  Combine training data and subject's own data to generate pathway priors.

> Step 2: Bedpost (cluster highly recommended for this step)
          -bedp to do this step

  Ball-and-stick model fitting on DWIs with bedpostx.

> Step 3: Pathway reconstruction
          -path to do this step

  Do the actual tractography.

> Step 4: Assemble pathway measures from multiple subjects
          -stat to do this step

   Combine whole-path or along-the-path measures (anisotropy and 
   diffusivity) from multiple subjects to feed into group analyses.

OTHER OPTIONS
-jobs <file>    : write a text file with command lines that can be
                  run in parallel but do not run them - the user can
                  then submit each line as a job on a compute cluster
-log <file>     : default is scripts/trac-all.log
-noappendlog    : overwrite old log files instead of appending
-cmd <file>     : default is scripts/trac-all.cmd
-no-isrunning   : do not check whether subjects are currently being processed
-sd subjectsdir : specify subjects dir (default env SUBJECTS_DIR)
-umask umask    : set unix file permission mask (default 002)
-grp groupid    : check that current group is alpha groupid 
-allowcoredump  : set coredump limit to unlimited
-debug          : print out more info and generate more files
-dontrun        : do everything but execute each command
-onlyversions   : print version of each binary and exit
-version        : print version of this script and exit
-help           : print full contents of help

FOR MARTINOS CENTER CLUSTER USERS
Do not submit trac-all as a job with pbsubmit or qsub. Run it directly on the
command line. If run on a local machine, trac-all will run all analyses locally.
If run on the cluster, trac-all will submit the analysis of each subject listed
in your dmrirc file as a job.

SEE ALSO: dmrirc.example

